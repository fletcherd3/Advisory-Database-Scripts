import os
import re
import dask
import dependent


INPUT_PATH = 'data/'

print("Opening Version Data")
data = dask.dataframe.read_csv(os.path.join(INPUT_PATH, 'libio-versions.csv'), header=0, dtype={'Project': 'str'})
data.set_index("Ecosystem")
data = data.persist()
print("Done")


def set_patched_versions(data):
    patched_versions = []
    for affected_version in data['affected']:
        patched_versions.append(check_patched_version(affected_version))
    return patched_versions


def check_patched_version(affected_version):
    if patch_exists(affected_version):
        return affected_version['ranges'][0]['events'][1]['fixed']
    return 'None'


def patch_exists(affected_version):
    return len(affected_version['ranges'][0]['events']) > 1


def set_affected_versions(data):
    affected_versions = []
    for affected_version in data['affected']:
        affected_versions.append(format_affected_version(affected_version))
    return affected_versions


def format_affected_version(affected_version):
    intro_unknown = introduction_unknown(affected_version)
    patch = patch_exists(affected_version)

    if intro_unknown and patch:
        return '< ' + affected_version['ranges'][0]['events'][1]['fixed']
    elif intro_unknown and not patch:
        return affected_version['database_specific']['last_known_affected_version_range']
    elif not intro_unknown and patch:
        return '>= ' + affected_version['ranges'][0]['events'][0]['introduced'] + ' < ' + affected_version['ranges'][0]['events'][1]['fixed']
    else:
        return '0'


def set_project_id(name, package_manager):
    # TODO Cannot get maven data due to weird naming convention

    df = data[data["Ecosystem"] == package_manager]
    df = df[df["Project"] == name]
    df = df[["ID", "Version"]]
    result = df.compute()
    print(result.to_dict())

    return "", []


def introduction_unknown(affected_version):
    return affected_version['ranges'][0]['events'][0]['introduced'] == '0'


class Vulnerability:
    def __init__(self, data):
        self.id = data['id']
        self.package = data['affected'][0]['package']['name']
        self.package_manager = dependent.PACKAGE_MANAGER[data['affected'][0]['package']['ecosystem']]
        self.affected_versions = set_affected_versions(data)
        self.patched_versions = set_patched_versions(data)
        self.projectId, self.versions = set_project_id(self.package, self.package_manager)

        print(self.versions)
        self.dependents = [] # dependent.set_dependents(self.projectId) # Direct Dependants

    def generate_dependents_str(self):
        dependent_str = "---------------------------------------------------\n"
        for depend in self.dependents:
            dependent_str += depend
        dependent_str += "---------------------------------------------------\n"
        return dependent_str

    def __str__(self):
        dependents_str = self.generate_dependents_str()
        return "===================================================\n" \
               "Vulnerability {0}:\n" \
               "Package: {1}\n" \
               "Package Manager: {2}\n" \
               "Affected Versions: {3}\n" \
               "Patched Versions: {4}\n" \
               "Project ID: {5} \n" \
               "Dependents: \n" \
               "{6} \n" \
               "===================================================\n".format(self.id, self.package,
                                                                              self.package_manager,
                                                                              self.affected_versions,
                                                                              self.patched_versions,
                                                                              self.projectId,
                                                                              dependents_str)
