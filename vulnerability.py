import os
import re
import dask
import pandas

import semver
import dependent


INPUT_PATH = 'data/'

print("Opening Version Data")
data = dask.dataframe.read_csv(os.path.join(INPUT_PATH, 'libio-versions.csv'), header=0, dtype={'Project': 'str'})
data.set_index("Ecosystem")
data = data.persist()
print("Done")


def set_patched_versions(data):
    patched_versions = []
    for affected_version in data['affected']:
        patched_versions.append(check_patched_version(affected_version))
    return patched_versions


def check_patched_version(affected_version):
    if patch_exists(affected_version):
        return affected_version['ranges'][0]['events'][1]['fixed']
    return 'None'


def patch_exists(affected_version):
    return len(affected_version['ranges'][0]['events']) > 1


def set_affected_ranges(data):
    return [format_affected_version(affected_version) for affected_version in data['affected']]


def format_affected_version(vulnerability_data):
    intro_unknown = introduction_unknown(vulnerability_data)
    patch = patch_exists(vulnerability_data)

    if intro_unknown and patch:
        return '< ' + vulnerability_data['ranges'][0]['events'][1]['fixed']
    elif intro_unknown and not patch:
        return vulnerability_data['database_specific']['last_known_affected_version_range']
    elif not intro_unknown and patch:
        return '>= ' + vulnerability_data['ranges'][0]['events'][0]['introduced'] + ' < ' + vulnerability_data['ranges'][0]['events'][1]['fixed']
    else:
        return '0'


def get_affected_versions(versions, vulnerability_data):
    """ Gets all specific versions that are effected by vulnerability"""
    affected_version_ranges = set_affected_ranges(vulnerability_data)
    affected_versions = []
    for v in versions:
        for r in affected_version_ranges:
            if _v
            _v = semver.valid(semver.clean(v, loose=True), loose=True)
            if semver.satisfies(_v, r, loose=True):
                affected_versions.append(_v)

    return affected_versions


def set_project_id_and_versions(name, package_manager, vulnerability_data):
    # TODO Cannot get maven data due to weird naming convention

    df = data[data["Ecosystem"] == package_manager]
    df = df[df["Project"] == name]
    df = df[["ID", "Version"]]
    result = df.compute()
    data_dict = result.to_dict(orient="list")
    print(data_dict["Version"])
    return data_dict['ID'][0], get_affected_versions(data_dict["Version"], vulnerability_data)


def introduction_unknown(affected_version):
    return affected_version['ranges'][0]['events'][0]['introduced'] == '0'


class Vulnerability:
    def __init__(self, data):
        self.id = data['id']
        self.package = data['affected'][0]['package']['name']
        self.package_manager = dependent.PACKAGE_MANAGER[data['affected'][0]['package']['ecosystem']]
        self.projectId, self.affected_versions = set_project_id_and_versions(self.package, self.package_manager, data)
        print(self.affected_versions)

        self.dependents = [] # dependent.set_dependents(self.projectId) # Direct Dependants

    def generate_dependents_str(self):
        dependent_str = "---------------------------------------------------\n"
        for depend in self.dependents:
            dependent_str += depend
        dependent_str += "---------------------------------------------------\n"
        return dependent_str

    def __str__(self):
        dependents_str = self.generate_dependents_str()
        return "===================================================\n" \
               "Vulnerability {0}:\n" \
               "Package: {1}\n" \
               "Package Manager: {2}\n" \
               "Affected Versions: {3}\n" \
               "Patched Versions: {4}\n" \
               "Project ID: {5} \n" \
               "Dependents: \n" \
               "{6} \n" \
               "===================================================\n".format(self.id, self.package,
                                                                              self.package_manager,
                                                                              self.affected_versions,
                                                                              self.patched_versions,
                                                                              self.projectId,
                                                                              dependents_str)
